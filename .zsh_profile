export LDFLAGS=-L/usr/local/opt/zlib/lib
export CPPFLAGS=-I/usr/local/opt/zlib/include
export CFLAGS=-I$(xcrun --show-sdk-path)/usr/include

export PYENV_ROOT=$HOME/.pyenv
export GOPATH=$HOME/go

export PATH=$PYENV_ROOT/shims:$PYENV_ROOT/bin:$GOPATH/bin:$PATH

export PACKER_CACHE_DIR=$HOME/packer_cache

if command -v pyenv 1>/dev/null 2>&1; then
  eval "$(pyenv init -)"
  eval "$(pyenv virtualenv-init -)"
fi

subnet-scan () {
  nmap -sP $1
}

cheat () {
  cheat_help() {
    echo "curl cht.sh! but be lazy about it..."
    echo "Along with the command 'cheat', enter the programming language you're dealing with, and you question."
    echo "Example: cheat bash 'what are computers'"
  }

  CHEAT_LANG=$1
  CHEAT_QUESTION="${@:2}"

  if [ -z "$CHEAT_LANG" ] || [ -z "$CHEAT_QUESTION" ]; then
    cheat_help
  else
    echo "curling cht.sh/$CHEAT_LANG/${CHEAT_QUESTION// /+}"
    curl cht.sh/$CHEAT_LANG/${CHEAT_QUESTION// /+}
  fi
}

sox () {
  sox_help() { echo "Helper utility to toggle the MacOS SOCKS proxy. Pass on or off to set proxy state." }

  case "$1" in
  on*|off*)
    networksetup -setsocksfirewallproxystate Wi-Fi $1
    echo "SOCKS proxy has been turned $1"
    ;;
  *)
    sox_help
    ;;
  esac
}

sox-ssh () {
  ssh -D 8080 $1
}

vnc-ssh () {
  ssh $1 -L 5901:127.0.0.1:5901
}

awssh () {
  ssh -l admin -F ssh.config $1
}

# AWS Account (Easily switch between profiles)
awsacc () {
  if [ -z "$1" ]; then
    echo $AWS_PROFILE
  elif [ "$1" = "ls" ]; then
    grep '\[*\]' ~/.aws/credentials
  else
    export AWS_PROFILE="$1"
  fi
}

# Get Private IP of EC2 Instance by name
awsip () {
  aws ec2 describe-instances --filters Name=tag:Name,Values=$1 --query "Reservations[].Instances[].PrivateIpAddress" --region $2 --output text
}

# EC2 Describe by name
ec2d () {
  aws ec2 describe-instances --filters Name=tag:Name,Values=$1 --query "Reservations[].Instances[]" --region $2 --output table
}

# Generate Password
gpw() {
  pwgen -Bsy $1 1 |pbcopy |pbpaste; echo “Has been copied to clipboard”
}

# Delete Known Host (by line number)
dkh() {
  sed -i.bak -e "$1d" ~/.ssh/known_hosts
}

docker-shell() {
  container=`docker container ls | sed -n 2p | awk '{print $1}'`
  docker exec -it $container /bin/bash
}

# Install cwd's requirements.txt into venvs used for deoplete
# NOTE: This function assumes the venvs being used for deoplete for python2 and 3
#       are named 'nvim2' and 'nvim3' respectively. This can be set in your nvim
#       config.
venv-init() {
  ~/.pyenv/versions/2.7.10/envs/nvim2/bin/pip install -r requirements.txt
  ~/.pyenv/versions/3.6.4/envs/nvim3/bin/pip install -r requirements.txt
}

# Listen on udp socket and print
los() {
  nc -u -l $1
}

# Generate an aes key w/ openssl
aes-key() {
  openssl rand -out out.key 32
}

# Wrap an aes key with a given RSAES OAEP SHA1 wrapping key
wrap-aes-key() {
  openssl rsautl -encrypt -in $1 -oaep -inkey $2 -pubin -keyform DER -out $1.enc
}

gen-priv-key() {
  help() {
    echo "Create a private key using OpenSSL with either RSA (default) or ECC (secp384r1)"
    echo "Args:"
    echo "  1. The name of the key to create"
    echo "  2. The type of key to create (optional)"
  }

  if [ -z "$2" ]; then
    TYPE="rsa"
  else
    TYPE=$2
  fi

  NAME=$1

  if [ -z "$NAME" ]; then
    help
  fi

  if [ "$TYPE" = "rsa" ]; then
    openssl genrsa -out $NAME 4096
  elif [ "$TYPE" = "ecc" ]; then
    openssl ecparam -out $NAME -name secp384r1 -genkey
  else
    help
  fi
}

# TODO: Make this function less stupid
encrypt-priv-key() {
  help() {
    echo "Encrypt an OpenSSL private key with a passphrase"
    echo "Args:"
    echo "  1. The path of the file to encrypt"
    echo "  2. The type of key we're encrypting (ecc or rsa) *Defaults to rsa*"
  }

  if [ -z "$2" ]; then
    TYPE="rsa"
  else
    TYPE=$2
  fi

  if [ -z "$1" ]; then
    help
  else
    if [ "$TYPE" = "ecc" ]; then
      openssl ec -in $1 -out $1 -aes256
    else
      openssl $TYPE -in $1 -out $1 -aes256
    fi
  fi
}

gen-csr() {
  help() {
    echo "Create a CSR using OpenSSL"
    echo "Args:"
    echo "  1. Path to private key"
    echo "  2. Path to create the csr file"
    echo "  3. Path to openssl.cnf"
  }

  KEY=$1
  CSR=$2
  CNF=$3

  if [ -z "$KEY" ] || [ -z "$CSR" ] || [ -z "$CNF" ]; then
    help
  else
    openssl req -new -key $KEY -out $CSR -config $CNF -sha384
  fi
}

alias vi='nvim'
alias vim='nvim'
alias git a='git add -A'
alias git cm='git commit -am'
alias cd..='cd ..'
alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias c='clear'
alias mkdir='mkdir -pv'
alias now='date +"%T"'
alias ping='ping -c 3'
alias vu='vagrant up'
alias vr='vd && vu'
alias vd='vagrant destroy -f'
alias vp='vagrant provision'
alias vs='vagrant status'
alias vss='vagrant ssh'
alias vgs='vagrant global-status'
alias vagrant destroy='vagrant destroy -f'
alias start-docker='open --background -a Docker'
alias stop-docker='test -z "$(docker ps -q 2>/dev/null)" && osascript -e "quit app \"Docker\""'
alias dic='docker rmi $(docker images --filter "dangling=true" -q)'
alias pgadmin='open /Applications/pgAdmin\ 4.app'
alias refresh-dns='sudo killall -HUP mDNSResponder'
alias t=todolist
alias read-csr='openssl req -text -noout -verify -in'
alias read-cert='`openssl x509 -noout -text -in'
